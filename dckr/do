#!/usr/bin/env bash
############################
# This is a simple to use shell script that ensures:
# - we always have a fresh base image matching our Dockerfile/do magic that gets rebuilt only if necessary
# - we always have a container started for that image, with our source mounted, that get restarted only if the image changed
# - we transparently pass any command to be exec-ed inside this container
############################

#ults-previous
#ults-current
#deb-current
#deb-next
#alpine-current

CONST_IMAGE_TARGET=${TARGET:-ults-current}
# shift
# Name of the image we are building
CONST_IMAGE_NAME=dckr-scape-bash-${CONST_IMAGE_TARGET}
# Label used to flag our containers
CONST_LABEL=com.dbdbdp.scape.bash

# Check that we have docker
if ! command -v docker >/dev/null; then
  printf "%s\\n" "$(date) [FATAL] You need to install docker."
  exit 1
fi

# Get the last git commit that changed the image or script, and whether they are dirty, to compute the tagname
TAG_NAME=$(git log -1 --pretty=%H dckr)
IS_DIRTY=$(git status --porcelain dckr)
# No tag name? This folder hasn't been committed yet...
if [ ! "$TAG_NAME" ]; then
  printf "%s\\n" "$(date) [WARNING] Your dckr folder in un-tracked."
  TAG_NAME=untracked
fi
# Dirty? Changes in there that haven't been committed. We are going to force a rebuild and restart every time.
if [ "$IS_DIRTY" ]; then
  printf "%s\\n" "$(date) [WARNING] Your dckr folder is dirty. The image will be rebuilt and the container restarted."
  TAG_NAME=${TAG_NAME}-dirty
fi

# List all existing containers with our label
if ! ALL_EXISTING_CONTAINERS=$(docker ps -aq --filter "label=${CONST_LABEL}"); then
  printf "%s\\n" "$(date) [ERROR] Docker failed!"
  exit 1
fi

# Build if the image for that git commit does not exist, or if the file is dirty
if [ ! "$(docker images ${CONST_IMAGE_NAME}:${TAG_NAME} -aq)" ] || [ "${IS_DIRTY}" ]; then
  printf "%s\\n" "$(date) [INFO] Building a new image."
  docker build --target "${CONST_IMAGE_TARGET}" -t ${CONST_IMAGE_NAME}:${TAG_NAME} -f dckr/Dockerfile . # > /dev/null
  # Since we know we rebuilt, let's get rid of every container in there
  if [ "${ALL_EXISTING_CONTAINERS}" ]; then
    printf "%s\\n" "$(date) [INFO] Removing existing out of date containers."
    docker rm -f ${ALL_EXISTING_CONTAINERS} > /dev/null
  fi
  ALL_EXISTING_CONTAINERS=
fi
# If we don't already have a running container for our image, cleanup all (including stopped, just to be sure) then start one
RUNNING_CONTAINER=$(docker ps -q --filter label=${CONST_LABEL}=${CONST_IMAGE_TARGET})
if [ ! "${RUNNING_CONTAINER}" ]; then
  printf "%s\\n" "$(date) [INFO] No currently running container for our image."
  if [ "${ALL_EXISTING_CONTAINERS}" ]; then
    printf "%s\\n" "$(date) [INFO] Removing existing out of date containers."
    docker rm -f ${ALL_EXISTING_CONTAINERS} > /dev/null
  fi
  printf "%s\\n" "$(date) [INFO] Starting new container from our image: ${CONST_IMAGE_NAME}:${TAG_NAME}."
  RUNNING_CONTAINER=$(docker run --detach --tty --restart always \
    --volume "$(pwd)":/project \
    --label=${CONST_LABEL}=${CONST_IMAGE_TARGET} \
    ${CONST_IMAGE_NAME}:${TAG_NAME})
fi
# Now, we know we have a running container from an up to date image, for sure
# We can now exec the command we were asked to perform
# Caveat: shell expansion happens on the host, unless you get your escaping right...
printf "%s\\n" "$(date) [INFO] Running command '$*' inside our running container '${RUNNING_CONTAINER}'."
docker exec -ti ${RUNNING_CONTAINER} $@
